<?php

//Auto-generated by ArtaxServiceBuilder - https://github.com/Danack/ArtaxServiceBuilder
//
//Do not be surprised if any changes to this file are over-written.
//
namespace GithubService\GithubAPI;

class GithubAPI implements \GithubService\GithubAPI
{

    /**
     * @var \ $userAgent
     */
    public $userAgent = null;

    /**
     * @var \ArtaxServiceBuilder\Service\Oauth1 $oauthService
     */
    public $oauthService = null;

    public function __construct($userAgent, \ArtaxServiceBuilder\Service\Oauth1 $oauthService = null)
    {
        $this->userAgent = $userAgent;
        $this->oauthService = $oauthService;
    }

    public function signRequest(\Artax\Request $request)
    {
        if ($this->oauthService == null) {
            throw new \ArtaxServiceBuilder\ArtaxServiceException("oauthService is null, so cannot call request that requires oauth.");
        }
        return $this->oauthService->signRequest($request);
    }

    public function callAPI(\Artax\Request $request, array $successStatuses = array())
    {
        $client = new \Artax\Client();

        $client->setOption('transfertimeout', 25);

        $response = $client->request($request);
        $status = $response->getStatus();
        $status = intval($status);

        if ($successStatuses != null  && in_array($status, $successStatuses)) {
            throw new \GithubService\GithubAPI\GithubAPIException(
                $response, 
                "Status does not match one of ".implode(', ', $successStatuses)
            );
        }
        else {
            if ($status < 200 || $status >= 300) {
                throw new \GithubService\GithubAPI\GithubAPIException(
                    $response, 
                    "Status $status is not 20x success."
                );
            }
        }

        return $response;
    }

    /**
     * @return
     */
    public function getUserAgent()
    {
        return $this->userAgent;
    }

    public function setUserAgent($value)
    {
        $this->userAgent = $value;
    }

    /**
     * getAuthorizations
     *
     * @param Authorization mixed The oauth2 bearer token
     */
    public function getAuthorizations($Authorization)
    {
        $instance = new getAuthorizations($this, $Authorization, $this->getuserAgent());
        return $instance;
    }

    /**
     * accessToken
     *
     * @param client_id mixed string Required. The client ID you received from GitHub
     * when you registered.
     * @param client_secret mixed string Required. The client secret you received from
     * GitHub when you registered.
     * @param code mixed string Required. The code you received as a response to Step
     * 1.
     * @param redirect_uri mixed string The URL in your app where users will be sent
     * after authorization. See details below about redirect urls.
     */
    public function accessToken($client_id, $client_secret, $code, $redirect_uri)
    {
        $instance = new accessToken($this, $this->getuserAgent(), $client_id, $client_secret, $code, $redirect_uri);
        return $instance;
    }

    /**
     * revokeAllAuthority
     *
     * @param Authorization mixed The oauth2 bearer token
     * @param client_id mixed The id of the client.
     */
    public function revokeAllAuthority($Authorization, $client_id)
    {
        $instance = new revokeAllAuthority($this, $Authorization, $this->getuserAgent(), $client_id);
        return $instance;
    }

    /**
     * getUserEmails
     *
     * Get users email addresses
     *
     * @param Authorization mixed The oauth2 bearer token
     */
    public function getUserEmails($Authorization)
    {
        $instance = new getUserEmails($this, $Authorization, $this->getuserAgent());
        return $instance;
    }

    /**
     * addUserEmails
     *
     * Get users email addresses
     *
     * @param Authorization mixed The oauth2 bearer token
     * @param emails mixed Array of the emails to add
     */
    public function addUserEmails($Authorization, $emails)
    {
        $instance = new addUserEmails($this, $Authorization, $this->getuserAgent(), $emails);
        return $instance;
    }

    /**
     * listUserRepos
     *
     * List repositories for the authenticated user. Note that this does not include
     * repositories owned by organizations which the user can access. You can list user
     * organizations and list organization repositories separately.
     *
     * @param Authorization mixed The oauth2 bearer token
     */
    public function listUserRepos($Authorization)
    {
        $instance = new listUserRepos($this, $Authorization, $this->getuserAgent());
        return $instance;
    }

    /**
     * getUserInfoByName
     *
     * @param Authorization mixed The oauth2 bearer token
     * @param username mixed The username of the client.
     */
    public function getUserInfoByName($Authorization, $username)
    {
        $instance = new getUserInfoByName($this, $Authorization, $this->getuserAgent(), $username);
        return $instance;
    }

    /**
     * getUserInfo
     *
     * @param Authorization mixed The oauth2 bearer token
     */
    public function getUserInfo($Authorization)
    {
        $instance = new getUserInfo($this, $Authorization, $this->getuserAgent());
        return $instance;
    }

    /**
     * listRepoTags
     *
     * List tags for a repository. Response can be paged. This can be used either as a
     * authed request (for private repos and higher rate limiting), or as unsigned,
     * (public only, lower limit).
     *
     * @param Authorization mixed The oauth2 bearer token
     * @param owner mixed 
     * @param repo mixed
     */
    public function listRepoTags($Authorization, $owner, $repo)
    {
        $instance = new listRepoTags($this, $Authorization, $this->getuserAgent(), $owner, $repo);
        return $instance;
    }

    /**
     * listRepoCommitsPaginate
     *
     * @param Authorization mixed The oauth2 bearer token
     * @param pageURL mixed
     */
    public function listRepoCommitsPaginate($Authorization, $pageURL)
    {
        $instance = new listRepoCommitsPaginate($this, $Authorization, $this->getuserAgent(), $pageURL);
        return $instance;
    }

    /**
     * listRepoCommits
     *
     * @param Authorization mixed The oauth2 bearer token
     * @param owner mixed 
     * @param repo mixed
     */
    public function listRepoCommits($Authorization, $owner, $repo)
    {
        $instance = new listRepoCommits($this, $Authorization, $this->getuserAgent(), $owner, $repo);
        return $instance;
    }

    /**
     * getSingleCommit
     *
     * @param Authorization mixed The oauth2 bearer token
     * @param owner mixed 
     * @param repo mixed 
     * @param sha mixed SHA of the commit to get
     */
    public function getSingleCommit($Authorization, $owner, $repo, $sha)
    {
        $instance = new getSingleCommit($this, $Authorization, $this->getuserAgent(), $owner, $repo, $sha);
        return $instance;
    }


}
