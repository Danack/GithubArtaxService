<?php

//Auto-generated by ArtaxServiceBuilder - https://github.com/Danack/ArtaxServiceBuilder
//
//Do not be surprised when any changes to this file are over-written.
//
namespace GithubService\Operation;

class createAuthorization implements \ArtaxServiceBuilder\Operation {

    /**
     * @var \GithubService\GithubArtaxService\GithubArtaxService
     */
    public $api = null;

    /**
     * @var array
     */
    public $parameters = null;

    /**
     * @var \Amp\Artax\Response
     */
    public $response = null;

    /**
     * @var \Amp\Artax\Response
     */
    public $originalResponse = null;

    /**
     * Get the last response.
     *
     * @return \Amp\Artax\Response
     */
    public function getResponse() {
        return $this->response;
    }

    /**
     * Set the last response. This should only be used by the API class when the
     * operation has been dispatched. Storing the response is required as some APIs
     * store out-of-bound information in the headers e.g. rate-limit info, pagination
     * that is not really part of the operation.
     */
    public function setResponse(\Amp\Artax\Response $response) {
        $this->response = $response;
    }

    public function __construct(\GithubService\GithubArtaxService\GithubArtaxService $api, $userAgent, $Authorization, $scopes, $note) {
        $defaultParams = [
            'Accept' => 'application/vnd.github.mirage-preview+json',
        ];
        $this->setParams($defaultParams);
        $this->api = $api;
        $this->parameters['userAgent'] = $userAgent;
        $this->parameters['Authorization'] = $Authorization;
        $this->parameters['scopes'] = $scopes;
        $this->parameters['note'] = $note;
    }

    public function setAPI(\GithubService\GithubArtaxService\GithubArtaxService $api) {
        $this->api = $api;
    }

    public function setParams(array $params) {
        if (array_key_exists('Accept', $params)) {
            $this->parameters['Accept'] = $params['Accept'];
        }
        if (array_key_exists('userAgent', $params)) {
            $this->parameters['userAgent'] = $params['userAgent'];
        }
        if (array_key_exists('Authorization', $params)) {
            $this->parameters['Authorization'] = $params['Authorization'];
        }
        if (array_key_exists('otp', $params)) {
            $this->parameters['otp'] = $params['otp'];
        }
        if (array_key_exists('scopes', $params)) {
            $this->parameters['scopes'] = $params['scopes'];
        }
        if (array_key_exists('note', $params)) {
            $this->parameters['note'] = $params['note'];
        }
        if (array_key_exists('note_url', $params)) {
            $this->parameters['note_url'] = $params['note_url'];
        }
        if (array_key_exists('client_id', $params)) {
            $this->parameters['client_id'] = $params['client_id'];
        }
        if (array_key_exists('client_secret', $params)) {
            $this->parameters['client_secret'] = $params['client_secret'];
        }
        if (array_key_exists('fingerprint', $params)) {
            $this->parameters['fingerprint'] = $params['fingerprint'];
        }
    }

    /**
     * Set Accept
     *
     * @return $this
     */
    public function setAccept($Accept) {
        $this->parameters['Accept'] = $Accept;

        return $this;
    }

    /**
     * Set userAgent
     *
     * The user-agent which allows Github to recognise your application.
     *
     * @return $this
     */
    public function setUserAgent($userAgent) {
        $this->parameters['userAgent'] = $userAgent;

        return $this;
    }

    /**
     * Set Authorization
     *
     * The basic authentication token
     *
     * @return $this
     */
    public function setAuthorization($Authorization) {
        $this->parameters['Authorization'] = $Authorization;

        return $this;
    }

    /**
     * Set otp
     *
     * The one time password.
     *
     * @return $this
     */
    public function setOtp($otp) {
        $this->parameters['otp'] = $otp;

        return $this;
    }

    /**
     * Set scopes
     *
     * @return $this
     */
    public function setScopes($scopes) {
        $this->parameters['scopes'] = $scopes;

        return $this;
    }

    /**
     * Set note
     *
     * @return $this
     */
    public function setNote($note) {
        $this->parameters['note'] = $note;

        return $this;
    }

    /**
     * Set note_url
     *
     * @return $this
     */
    public function setNote_url($note_url) {
        $this->parameters['note_url'] = $note_url;

        return $this;
    }

    /**
     * Set client_id
     *
     * The 20 character OAuth app client key for which to create the token.
     *
     * @return $this
     */
    public function setClient_id($client_id) {
        $this->parameters['client_id'] = $client_id;

        return $this;
    }

    /**
     * Set client_secret
     *
     * The 40 character OAuth app client secret for which to create the token.
     *
     * @return $this
     */
    public function setClient_secret($client_secret) {
        $this->parameters['client_secret'] = $client_secret;

        return $this;
    }

    /**
     * Set fingerprint
     *
     * A unique string to distinguish an authorization from others created for the same
     * client ID and user.
     *
     * @return $this
     */
    public function setFingerprint($fingerprint) {
        $this->parameters['fingerprint'] = $fingerprint;

        return $this;
    }

    public function getParameters() {
        return $this->parameters;
    }

    /**
     * Apply any filters necessary to the parameter
     *
     * @return \GithubService\Model\OauthAccess
     * @param string $name The name of the parameter to get.
     */
    public function getFilteredParameter($name) {
        if (array_key_exists($name, $this->parameters) == false) {
            throw new \Exception('Parameter '.$name.' does not exist.');
        }

        $value = $this->parameters[$name];


        return $value;
    }

    /**
     * Create an Amp\Artax\Request object from the operation.
     *
     * @return \Amp\Artax\Request
     */
    public function createRequest() {
        $request = new \Amp\Artax\Request();
        $url = null;
        $request->setMethod('POST');


        $jsonParams = [];
        if (array_key_exists('Accept', $this->parameters) == true) {
        $value = $this->getFilteredParameter('Accept');
            $request->setHeader('Accept', $value);
        }
        $value = $this->getFilteredParameter('userAgent');
        $request->setHeader('User-Agent', $value);
        $value = $this->getFilteredParameter('Authorization');
        $request->setHeader('Authorization', $value);
        if (array_key_exists('otp', $this->parameters) == true) {
        $value = $this->getFilteredParameter('otp');
            $request->setHeader('X-GitHub-OTP', $value);
        }
        $value = $this->getFilteredParameter('scopes');
        $jsonParams['scopes'] = $value;
        $value = $this->getFilteredParameter('note');
        $jsonParams['note'] = $value;
        if (array_key_exists('note_url', $this->parameters) == true) {
        $value = $this->getFilteredParameter('note_url');
            $jsonParams['note_url'] = $value;
        }
        if (array_key_exists('client_id', $this->parameters) == true) {
        $value = $this->getFilteredParameter('client_id');
            $jsonParams['client_id'] = $value;
        }
        if (array_key_exists('client_secret', $this->parameters) == true) {
        $value = $this->getFilteredParameter('client_secret');
            $jsonParams['client_secret'] = $value;
        }
        if (array_key_exists('fingerprint', $this->parameters) == true) {
        $value = $this->getFilteredParameter('fingerprint');
            $jsonParams['fingerprint'] = $value;
        }

        //Parameters are parsed and set, lets prepare the request
        if (count($jsonParams)) {
            $jsonBody = json_encode($jsonParams);
            $request->setHeader("Content-Type", "application/json");
            $request->setBody($jsonBody);
        }
        if ($url == null) {
            $url = "https://api.github.com/authorizations";
        }
        $request->setUri($url);

        return $request;
    }

    /**
     * Create and execute the operation, returning the raw response from the server.
     *
     * @return \Amp\Artax\Response
     */
    public function createAndExecute() {
        $request = $this->createRequest();
        $response = $this->api->execute($request, $this);
        $this->response = $response;

        return $response;
    }

    /**
     * Create and execute the operation, then return the processed  response.
     *
     * @return mixed|\GithubService\Model\OauthAccess
     */
    public function call() {
        $request = $this->createRequest();
        $response = $this->api->execute($request, $this);
        $this->response = $response;

        if ($this->shouldResponseBeProcessed($response)) {
            $instance = \GithubService\Model\OauthAccess::createFromResponse($response, $this);

            return $instance;
        }
        return $response;
    }

    /**
     * Execute the operation, returning the parsed response
     *
     * @return \GithubService\Model\OauthAccess
     */
    public function execute() {
        $request = $this->createRequest();
        return $this->dispatch($request);
    }

    /**
     * Execute the operation asynchronously, passing the parsed response to the
     * callback
     *
     * @return \Amp\Promise
     */
    public function executeAsync(callable $callable) {
        $request = $this->createRequest();
        return $this->dispatchAsync($request, $callable);
    }

    /**
     * Dispatch the request for this operation and process the response. Allows you to
     * modify the request before it is sent.
     *
     * @return \GithubService\Model\OauthAccess
     * @param \Amp\Artax\Request $request The request to be processed
     */
    public function dispatch(\Amp\Artax\Request $request) {
        $response = $this->api->execute($request, $this);
        $this->response = $response;
        $instance = \GithubService\Model\OauthAccess::createFromResponse($response, $this);

        return $instance;
    }

    /**
     * Dispatch the request for this operation and process the response asynchronously.
     * Allows you to modify the request before it is sent.
     *
     * @return \GithubService\Model\OauthAccess
     * @param \Amp\Artax\Request $request The request to be processed
     * @param callable $callable The callable that processes the response
     */
    public function dispatchAsync(\Amp\Artax\Request $request, callable $callable) {
        return $this->api->executeAsync($request, $this, $callable);
    }

    /**
     * Dispatch the request for this operation and process the response. Allows you to
     * modify the request before it is sent.
     *
     * @return \GithubService\Model\OauthAccess
     * @param \Amp\Artax\Response $response The HTTP response.
     */
    public function processResponse(\Amp\Artax\Response $response) {
        $instance = \GithubService\Model\OauthAccess::createFromResponse($response, $this);

        return $instance;
    }

    /**
     * Determine whether the response should be processed. Override this method to have
     * a per-operation decision, otherwise the function is the API class will be used.
     *
     * @return \GithubService\Model\OauthAccess
     */
    public function shouldResponseBeProcessed(\Amp\Artax\Response $response) {
        return $this->api->shouldResponseBeProcessed($response);
    }

    /**
     * Determine whether the response is an error. Override this method to have a
     * per-operation decision, otherwise the function from the API class will be used.
     *
     * @return null|\ArtaxServiceBuilder\BadResponseException
     */
    public function translateResponseToException(\Amp\Artax\Response $response) {
        return $this->api->translateResponseToException($response);
    }

    /**
     * Determine whether the response indicates that we should use a cached response.
     * Override this method to have a per-operation decision, otherwise the
     * functionfrom the API class will be used.
     *
     * @return \GithubService\Model\OauthAccess
     */
    public function shouldUseCachedResponse(\Amp\Artax\Response $response) {
        return $this->api->shouldUseCachedResponse($response);
    }

    /**
     * Determine whether the response should be cached. Override this method to have a
     * per-operation decision, otherwise the function from the API class will be used.
     *
     * @return \GithubService\Model\OauthAccess
     */
    public function shouldResponseBeCached(\Amp\Artax\Response $response) {
        return $this->api->shouldResponseBeCached($response);
    }

    /**
     * Set the original response. This may be different from the cached response if one
     * is used.
     */
    public function setOriginalResponse(\Amp\Artax\Response $response) {
        $this->originalResponse = $response;
    }

    /**
     * Get the original response. This may be different from the cached response if one
     * is used.
     *
     * @return \Amp\Artax\Response
     */
    public function getOriginalResponse() {
        return $this->originalResponse;
    }


}
